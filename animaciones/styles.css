/* 
  üîë ¬øQu√© son los Keyframes?
  Los keyframes son la base de cualquier animaci√≥n CSS. Son esenciales para
  definir los estados inicial y final de la animaci√≥n.

  üöÄ Creando una Animaci√≥n
  Para aplicar la animaci√≥n, necesitas definir el nombre de la animaci√≥n y
  su duraci√≥n:

  @keyframes move {
    from {
      transform: translateY(0);
    }
    to {
      transform: translateY(100px);
    }
  }

  .elemento {
    animation: move 3s;
  }

  ‚è≥ Duraci√≥n de la Animaci√≥n
  Es importante especificar la duraci√≥n de la animaci√≥n correctamente.
  Sin ella, la animaci√≥n no se ejecutar√° como deseas.

  ‚öôÔ∏è ¬øQu√© es animation-fill-mode?
  Por defecto, despu√©s de que una animaci√≥n se completa, los elementos vuelven
  a su estado inicial. Esto puede resultar en un comportamiento inesperado. La
  propiedad animation-fill-mode permite que el elemento mantenga su estilo tras
  finalizar la animaci√≥n.

  Tipos de animation-fill-mode
  - none: El valor predeterminado, donde el elemento no mantiene ning√∫n cambio.
  - forwards: Mantiene el estilo del keyframe final una vez que termina la animaci√≥n.
  - backwards: Aplica el keyframe inicial cuando la animaci√≥n comienza y el
  elemento se ve afectado inmediatamente antes de la animaci√≥n.
  both: Combina ambos comportamientos, mostrando el keyframe inicial al
  comenzar y el keyframe final al finalizar.


  ‚öôÔ∏è Consideraciones de Rendimiento
  Las animaciones CSS son eficientes porque se ejecutan en GPU, lo que reduce el
  impacto en el rendimiento en comparaci√≥n con las animaciones basadas en JavaScript.

  Notas de rendimiento:
  1. Las propiedades width, height, margin y padding causan que cambie el layout
  y esto genera reflow costoso afectando negativamente el rendimiento.
  2. Las propiedades transform y opacity solo requieren repaint por lo que
  evitan reflow y se manejan eficientemente meorando el rendimiento de las
  animaciones CSS.

  will-change:
  Es una declaraci√≥n que informa al navegador qu√© propiedades van a cambiar para optimizar
  antes de la animaci√≥n.
*/

.pulser {
  position: relative;
  width: 50px;
  height: 50px;
  background: #09f;
  border-radius: 100%;
}

.pulser::after {
  content: "";
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  background: #09f;
  border-radius: 50%;
  z-index: -1;
  animation-name: pulse;
  animation-duration: 2s;
  animation-delay: 1s;
  animation-timing-function: ease-in-out;
  animation-iteration-count: infinite;
}

@keyframes pulse {
  0% {
    opacity: 0;
  }

  50% {
    scale: 1.4;
    opacity: 0.4;
  }

  100% {
    opacity: 0.6;
  }
}

@keyframes move {
  from {
    transform: translateY(0px);
  }

  to {
    transform: translateY(100px);
  }
}

body {
  display: grid;
  place-content: center;
  min-height: 50vh;
}

img {
  width: 80px;
  animation-name: mover;
  animation-duration: 2s;
  /* animation-iteration-count: infinite; */
  animation-timing-function: linear;
  animation-direction: alternate;
  animation-fill-mode: both;

  /*
    La propiedad animation permite definir animaciones de manera compacta.
    Puedes combinar varias animaciones utilizando comas para especificar
    diferentes efectos:
  */
  animation: mover 2s steps(10) both, agrandar 1s linear 2s both;
}

img {
  &:hover {
    animation-play-state: paused;
    opacity: 0.7;
    filter: contraste(150%);
    cursor: progress;
  }
}

@keyframes agrandar {
  0% {
    scale: 1;
  }

  25% {
    scale: 1.4;
  }

  50% {
    scale: 2;
  }

  75% {
    scale: 1.6;
  }

  100% {
    scale: 2;
  }
}

@keyframes mover {
  to {
    transform: translateX(200px);
  }
}
